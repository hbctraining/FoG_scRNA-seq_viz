[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "index.html#sequencing-read-quality",
    "href": "index.html#sequencing-read-quality",
    "title": "",
    "section": "Sequencing read quality",
    "text": "Sequencing read quality\nA first step in quality assessment of data is to evaluate some key sequence read metrics which can help identify technical artifacts and ensure robust downstream analyses. Some examples of these include:\n\nMean Reads per Cell: the total number of sequenced reads divided by the number of cells. 10X recommends a minimum of 20,000 read pairs per cell.\nValid Barcodes: shows the fraction of reads with barcodes that match the inclusion list after barcode correction. Low valid barcodes (&lt;75%) may indicate sequencing issues or sample/library preparation issues.\nMapping Rate: The percentage of reads that align successfully to the transcriptome. Overall, we would like the reads mapped to the genome to be high (for example, &gt;85% for mouse or human), but could vary depending on the species.\n\nIntergenic reads should be low. Intronic reads can be higher when the sample is prepared from nuclei or cells with high-level of intron retention (i.e. neutrophils)\n\nFraction Reads in Cells: shows the fraction of valid-barcode, confidently-mapped reads with cell-associated barcodes. Lower percentages (&lt; 70%) indicate that a high level of ambient RNA partitioned into all (cell-containing and non-cell-containing) GEMs.\n\n\nBarcode rank plot\nThe barcode rank plot is an important visualization which shows the distribution of UMI counts in barcodes. All detected barcodes are plotted in decreasing order of the number of UMIs associated with that particular barcode. The shape of these plots can indicate a few different things about the sample:\n\nTypical: Clear cliff and knee with separation between cells and background.\nHeterogeneous: Bimodal plot with 2 cliffs and knees, with a clear divide between cells and background.\nCompromised: Round curve with a steep drop-off at the end whih indicated low quality due to many factors.\nCompromised: Defined cliff and knee, but with few barcodes detected could be due to inaccurate cell count or clogging."
  },
  {
    "objectID": "index.html#cell-level-quality-metrics",
    "href": "index.html#cell-level-quality-metrics",
    "title": "",
    "section": "Cell-level quality metrics",
    "text": "Cell-level quality metrics\nTo determine low quality cells that should be removed from the analysis, various metrics are assessed. Visualizations of these metrics aid in determining the filtering thresholds for removal of the low quality cells. Below, we present visualizations to display these metrics across cells within each sample in our dataset.\n\nCell counts\nThe cell counts are determined by the number of unique cellular barcodes detected. In an ideal world, you would expect the number of unique cellular barcodes to correspond to the number of cells you loaded. However, this is not the case as capture rates of cells are only a proportion of what is loaded.\n\n\n\n\n\n\nNote\n\n\n\nThe capture efficiency could appear much lower if the cell concentration used for library preparation was not accurate. Cell concentration should NOT be determined by FACS machine or Bioanalyzer (these tools are not accurate for concentration determination), instead use a hemocytometer or automated cell counter for calculation of cell concentration.\n\n\nThe cell numbers can also vary by protocol, producing cell numbers that are much higher than what we loaded. Some examples of how this could happen include:\n\nThe cellular barcodes are present in the emulsion droplet, with no actual cell.\nOccasionally a droplet can have more than one cellular barcode.\nPresence of dying cells can lead to a higher number of cellular barcodes than cells.\n\n\n# Load libraries\nlibrary(Seurat)\nlibrary(tidyverse)\n\n# Read in metadata\nmetadata &lt;- readRDS(\"data/QC_metadata.rds\")\n\n# Visualize the number of cell counts per sample\nmetadata %&gt;% \n    ggplot(aes(x=sample, fill=sample)) + \n    geom_bar() +\n    theme_classic() +\n    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +\n    theme(plot.title = element_text(hjust=0.5, face=\"bold\")) +\n    ggtitle(\"NCells\")\n\n\n\n\nWe see over 15,000 cells per sample, which is quite a bit more than the 12-13,000 expected. It is clear that we likely have some junk ‘cells’ present.\n\n\nUMI counts per cell\nThe UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply.\n\n\nGenes detected per cell\nWe have similar expectations for gene detection as for UMI detection, although it may be a bit lower than UMIs. For high quality data, the proportional histogram should contain a single large peak that represents cells that were encapsulated.\nIf we see a small shoulder to the left of the major peak (not present in our data), or a bimodal distribution of the cells, that can indicate a couple of things. It might be that there are a set of cells that failed for some reason. It could also be that there are biologically different types of cells (i.e. quiescent cell populations, less complex cells of interest), and/or one type is much smaller than the other (i.e. cells with high counts may be cells that are larger in size). Therefore, this threshold should be assessed with other metrics.\n\n# Visualize the distribution of genes detected per cell via histogram\nmetadata %&gt;% \n    ggplot(aes(color=sample, x=nGene, fill= sample)) + \n    geom_density(alpha = 0.2) + \n    theme_classic() +\n    scale_x_log10() + \n    geom_vline(xintercept = 300)\n\n\n\n\n\n\nFraction of reads mapping to mitochondrial genes\nThis metric can identify whether there is a large amount of mitochondrial contamination from dead or dying cells. We define poor quality samples for mitochondrial counts as cells which surpass the 0.2 mitochondrial ratio mark, unless of course you are expecting this in your sample.\n\n\nJoint filtering\nConsidering any of these QC metrics in isolation can lead to misinterpretation of cellular signals. For example, cells with a comparatively high fraction of mitochondrial counts may be involved in respiratory processes and may be cells that you would like to keep. Likewise, other metrics can have other biological interpretations. A general rule of thumb when performing QC is to set thresholds for individual metrics to be as permissive as possible, and always consider the joint effects of these metrics. In this way, you reduce the risk of filtering out any viable cell populations.\nTwo metrics that are often evaluated together are the number of UMIs and the number of genes detected per cell. Here, we have plotted the number of genes versus the number of UMIs coloured by the fraction of mitochondrial reads. Jointly visualizing the count and gene thresholds and additionally overlaying the mitochondrial fraction, gives a summarized persepective of the quality per cell.\n\n# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs\nmetadata %&gt;% \n    ggplot(aes(x=nUMI, y=nGene, color=mitoRatio)) + \n    geom_point() + \n    scale_colour_gradient(low = \"gray90\", high = \"black\") +\n    stat_smooth(method=lm) +\n    scale_x_log10() + \n    scale_y_log10() + \n    theme_classic() +\n    geom_vline(xintercept = 500) +\n    geom_hline(yintercept = 250) +\n    facet_wrap(~sample)\n\n\n\n\nGood cells will generally exhibit both higher number of genes per cell and higher numbers of UMIs (upper right quadrant of the plot). Cells that are poor quality are likely to have low genes and UMIs per cell, and correspond to the data points in the bottom left quadrant of the plot. With this plot we also evaluate the slope of the line, and any scatter of data points in the bottom right hand quadrant of the plot. These cells have a high number of UMIs but only a few number of genes. These could be dying cells, but also could represent a population of a low complexity celltype (i.e red blood cells).\nMitochondrial read fractions are only high in particularly low count cells with few detected genes (darker colored data points). This could be indicative of damaged/dying cells whose cytoplasmic mRNA has leaked out through a broken membrane, and thus, only mRNA located in the mitochondria is still conserved. We can see from the plot, that these cells are filtered out by our count and gene number thresholds.\nAfter deciding on our quality thresholds and filtering the data, we would re-run the plots to ensure good quality metrics post-filtering. Based on the quality filtering, we should now have true cells of high quality and identified any failed samples."
  },
  {
    "objectID": "index.html#evaluating-effects-of-cell-cycle",
    "href": "index.html#evaluating-effects-of-cell-cycle",
    "title": "",
    "section": "Evaluating effects of cell cycle",
    "text": "Evaluating effects of cell cycle\nTo assign each cell a score based on its expression of G2/M and S phase markers, we have used the Seurat function CellCycleScoring(). This function calculates cell cycle phase scores based on canonical markers that required as input. After scoring the cells for cell cycle, we would like to determine whether cell cycle is a major source of variation in our dataset using PCA.\n\n# Load in the Seurat object\nseurat_phase &lt;- readRDS(\"data/QC_seurat_phase.rds\")\nseurat_phase\n\nAn object of class Seurat \n14065 features across 29629 samples within 1 assay \nActive assay: RNA (14065 features, 2000 variable features)\n 3 layers present: counts, data, scale.data\n 1 dimensional reduction calculated: pca\n\n\n\nHighly variable genes\nTo perform PCA, we need to first choose the most variable features, then scale the data. Since highly expressed genes exhibit the highest amount of variation and we don’t want our ‘highly variable genes’ only to reflect high expression, we need to scale the data to scale variation with expression level.\nSeurat allows us to access the ranked highly variable genes with the VariableFeatures() function. We can additionally visualize the dispersion of all genes using Seurat’s VariableFeaturePlot(), which shows a gene’s average expression across all cells on the x-axis and variance on the y-axis. Ideally we want to use genes that have high variance since this can indicate a change in expression depending on populations of cells. Adding labels using the LabelPoints() helps us understand which genes will be driving shape of our data.\n\n# Identify the 15 most highly variable genes\nranked_variable_genes &lt;- VariableFeatures(seurat_phase)\ntop_genes &lt;- ranked_variable_genes[1:15]\n\n# Plot the average expression and variance of these genes\n# With labels to indicate which genes are in the top 15\np &lt;- VariableFeaturePlot(seurat_phase)\nLabelPoints(plot = p, points = top_genes, repel = TRUE)\n\n\n\n\n\n\nPCA\nPrincipal Component Analysis (PCA) is a technique used to emphasize variation as well as similarity, and to bring out strong patterns in a dataset; it is one of the methods used for “dimensionality reduction”.\n\n\n\n\n\n\nPCA\n\n\n\nFor a more detailed explanation on PCA, please look over this lesson (adapted from StatQuests/Josh Starmer’s YouTube video). We also strongly encourage you to explore the video StatQuest’s video for a more thorough understanding.\n\n\n\n# Perform PCA\nseurat_phase &lt;- RunPCA(seurat_phase)\n\n# Plot the PCA colored by cell cycle phase\nDimPlot(seurat_phase,\n        reduction = \"pca\",\n        group.by= \"Phase\",\n        split.by = \"Phase\")\n\n\n\n\nHere, we have performed the PCA analysis using the most highly variable genes and plotted the first two principal components against each other. We have also split the figure by cell cycle phase, to evaluate similarities and/or differences. We do not see large differences due to cell cycle phase. Based on this plot, we would not regress out the variation due to cell cycle.\n\n\nWhen should cell cycle phase be regressed out?\n\nBelow are two PCA plots taken from the Seurat vignette dealing with Cell-Cycle Scoring and Regression.\n\n\nThis first plot is similar to what we plotted above, it is a PCA prior to regression to evaluate if the cell cycle is playing a big role in driving PC1 and PC2. Clearly, the cells are separating by cell type in this case, so the vignette suggests regressing out these effects.\n\n\n\n\n\n\n\nThis second PCA plot is post-regression, and displays how effective the regression was in removing the effect we observed."
  },
  {
    "objectID": "index.html#sctransform",
    "href": "index.html#sctransform",
    "title": "",
    "section": "SCTransform",
    "text": "SCTransform\nIn the Hafemeister and Satija, 2019 paper the authors explored the issues with simple transformations. Specifically they evaluated the standard log normalization approach and found that:\n\ngenes with different abundances are affected differently and that **effective normalization (using the log transform) is only observed with low/medium abundance genes (Figure 1D, below)\nsubstantial imbalances in variance were observed with the log-normalized data (Figure 1E, below)\n\ncells with low total UMI counts exhibited disproportionately higher variance for high-abundance genes, dampening the variance contribution from other gene abundances\n\n\n\n\n\nImage credit: Hafemeister C and Satija R. Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genom Biology 2019 (https://doi.org/10.1101/576827)\nThe conclusion is, we cannot treat all genes the same.\nThe proposed solution was the use of Pearson residuals for transformation, as implemented in Seurat’s SCTransform function. With this approach:\n\nMeasurements are multiplied by a gene-specific weight\nEach gene is weighted based on how much evidence there is that it is non-uniformly expressed across cells\nMore evidence == more of a weight; Genes that are expressed in only a small fraction of cells will be favored (useful for finding rare cell populations)\nNot just a consideration of the expression level is, but also the distribution of expression"
  },
  {
    "objectID": "index.html#to-integrate-or-not-to-integrate",
    "href": "index.html#to-integrate-or-not-to-integrate",
    "title": "",
    "section": "To integrate or not to integrate?",
    "text": "To integrate or not to integrate?\nGenerally, we always look at our clustering without integration before deciding whether we need to perform any alignment. Do not just always perform integration because you think there might be differences - explore the data. If we had performed the normalization on both conditions together in a Seurat object and visualized the similarity between cells, we would have seen condition-specific clustering:\n\n\n\nCondition-specific clustering of the cells indicates that we need to integrate the cells across conditions to ensure that cells of the same cell type cluster together.\nWhy is it important the cells of the same cell type cluster together?\nWe want to identify cell types which are present in all samples/conditions/modalities within our dataset, and therefore would like to observe a representation of cells from both samples/conditions/modalities in every cluster. This will enable more interpretable results downstream (i.e. DE analysis, ligand-receptor analysis, differential abundance analysis…)."
  },
  {
    "objectID": "index.html#approaches-for-integration",
    "href": "index.html#approaches-for-integration",
    "title": "",
    "section": "Approaches for integration",
    "text": "Approaches for integration\nTo integrate, we will use the shared highly variable genes (identified using SCTransform) from each group, then, we will “integrate” or “harmonize” the groups to overlay cells that are similar or have a “common set of biological features” between groups. Integration is a powerful method that uses these shared sources of greatest variation to identify shared subpopulations across conditions or datasets [Stuart and Bulter et al. (2018)]. The goal of integration is to ensure that the cell types of one condition/dataset align with the same celltypes of the other conditions/datasets (e.g. macrophages in one sample align with macrophages in the other samples).\n\nCanonical Correlation Analysis (CCA)\nCCA is a form of PCA, in that it identifies the greatest sources of variation in the data, but only if it is shared or conserved across the conditions/groups (using the 3000 most variant genes from each sample). The shared highly variable genes are used to identify anchors or mutual nearest neighbors (MNNs) across datasets and incorrect anchors are filtered out. The anchors and corresponding scores are used to transform the cell expression values, allowing for the integration of the conditions/datasets.\n\n\nHarmony\nHarmony was devleoped in 2019, and is an example of a tool that can work with complex integration tasks (integrating across multiple covariates). Instead of using CCA, Harmony applies a transformation to the principal component (PCs) values, using all available PCs, e.g. as pre-computed within the Seurat workflow. In this space of transformed PCs, Harmony uses k-means clustering to delineate clusters, seeking to define clusters with maximum “diversity”.\nFor this dataset, we applied CCA integration. To evaluate the effect of integration, we can visualize the aligned data in a UMAP to ensure we now have proper alignment across our samples.\n\n# Plot UMAP\nseurat_integrated &lt;- readRDS(\"data/integrated_seurat.rds\")\nDimPlot(seurat_integrated)  \n\n\n\n\n\n# Plot UMAP split by sample\nDimPlot(seurat_integrated,\n        split.by = \"sample\")"
  },
  {
    "objectID": "index.html#exploration-of-qc-metrics",
    "href": "index.html#exploration-of-qc-metrics",
    "title": "",
    "section": "Exploration of QC metrics",
    "text": "Exploration of QC metrics\nLet’s begin by using a barplot to take a look at the number of cells per cluster, and whether there are similar amounts of cells present from each of the conditions. Large differences observed could indicate compositional change between conditions and may warrant further downstream analysis.\n\n# Extract identity and sample information from seurat object to \n# determine the number of cells per cluster per sample\nn_cells &lt;- FetchData(seurat_clustered, \n                     vars = c(\"ident\", \"sample\")) %&gt;%\n        dplyr::count(ident, sample)\n\n# Barplot of number of cells per cluster by sample\nggplot(n_cells, aes(x=ident, y=n, fill=sample)) +\n    geom_bar(position=position_dodge(), stat=\"identity\") +\n    geom_text(aes(label=n), vjust = -.2, position=position_dodge(1))\n\n\n\n\nTo determine whether our clusters might be due to artifacts such as cell cycle phase, mitochondrial expression, or junk, it can be useful to explore various metrics visually to see if any clusters exhibit enrichment or are different from the other clusters. If enrichment or differences are observed for particular clusters it may not be worrisome if it can be explained by the particular cell type.\nNext let’s explore these metrics by overlaying them on the UMAP using a FeaturePlot:\n\n# Determine metrics to plot present in seurat_integrated@meta.data\nmetrics &lt;-  c(\"nUMI\", \"nGene\", \"S.Score\", \"G2M.Score\", \"mitoRatio\")\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = metrics,\n            pt.size = 0.4, \n            order = TRUE,\n            min.cutoff = 'q10',\n            label = TRUE)\n\n\n\n\nWith the color scale of the FeaturePlots, it can be difficult to distinguish the precise effect on individual clusters. Next, we use boxplots to zoom in on the number of genes expressed in each cluster and more quantitatively assess the differences. The corresponding UMAP is displayed for comparison.\n\n# Boxplot of nGene per cluster\nggplot(seurat_clustered@meta.data) +\n    geom_boxplot(aes(x=integrated_snn_res.0.8, y=nGene, fill=integrated_snn_res.0.8)) +\n    NoLegend()"
  },
  {
    "objectID": "index.html#exploring-known-celltype-markers",
    "href": "index.html#exploring-known-celltype-markers",
    "title": "",
    "section": "Exploring known celltype markers",
    "text": "Exploring known celltype markers\nWe can explore the different clusters and best identify their cell type identities by looking at expression of known marker genes. Depending on our markers of interest, they could be positive or negative markers for a particular cell type. The combined expression of our chosen handful of markers should give us an idea on whether a cluster corresponds to that particular cell type. In teh example below, CD14+ monocyte markers appear to correspond to clusters 1, and 3. We wouldn’t include clusters 14 and 10 because they do not highly express both of these markers.\n\nFeature Plot\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"CD14\", \"LYZ\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\n\nViolin plot\nWe can also explore the range in expression of specific markers by using violin plots. Violin plots are similar to box plots, except that they also show the probability density of the data at different values, usually smoothed by a kernel density estimator. A violin plot is more informative than a plain box plot. While a box plot only shows summary statistics such as mean/median and interquartile ranges, the violin plot shows the full distribution of the data. The difference is particularly useful when the data distribution is multimodal (more than one peak). In this case a violin plot shows the presence of different peaks, their position and relative amplitude.\n\n# Violin plot - CD14+ monocyte\nVlnPlot(object = seurat_clustered, \n        features = c(\"CD14\", \"LYZ\"))\n\n\n\n\n\n\nDotplot\nWhile the above plot allows you to explore one celltype at a time, Seurat also has a built in visualization tool which allows us to view the average expression of genes across clusters called DotPlot(). This function also shows us what percentage of cells within the cluster express the given gene (dot size). As input, we supply a list of genes - note that we cannot use the same gene twice or an error will be thrown.\n\n# List of known celltype markers\nmarkers &lt;- list()\nmarkers[[\"CD14+ monocytes\"]] &lt;- c(\"CD14\", \"LYZ\")\nmarkers[[\"FCGR3A+ monocyte\"]] &lt;- c(\"FCGR3A\", \"MS4A7\")\nmarkers[[\"Macrophages\"]] &lt;- c(\"MARCO\", \"ITGAM\", \"ADGRE1\")\nmarkers[[\"Conventional dendritic\"]] &lt;- c(\"FCER1A\", \"CST3\")\nmarkers[[\"Plasmacytoid dendritic\"]] &lt;- c(\"IL3RA\", \"GZMB\", \"SERPINF1\", \"ITM2C\")\n\n# Create dotplot based on RNA expression\nDotPlot(seurat_clustered, markers, assay=\"RNA\")"
  },
  {
    "objectID": "index.html#celltype-assignment",
    "href": "index.html#celltype-assignment",
    "title": "",
    "section": "Celltype assignment",
    "text": "Celltype assignment\nAfter identifying the majority of clusters using known cell type markers, we can move on to marker identification, which will allow us to verify the identity of certain clusters and help surmise the identity of any unknown clusters. We can use the same plots to explore the expression of new markers as the known markers. Once we have identified the cell types, we can assign the cell type names to each cluster.\n\n# Rename all identities\nseurat_clustered &lt;- RenameIdents(object = seurat_clustered, \n                                  \"0\" = \"Naive or memory CD4+ T cells\",\n                                  \"1\" = \"Activated T cells\",\n                                  \"2\" = \"CD14+ monocytes\",\n                                  \"3\" = \"CD14+ monocytes\",\n                                  \"4\" = \"Stressed cells / Unknown\",\n                                  \"5\" = \"CD8+ T cells\",\n                                  \"6\" = \"Naive or memory CD4+ T cells\",\n                                  \"7\" = \"B cells\",\n                                  \"8\" = \"NK cells\",\n                                  \"9\" = \"CD8+ T cells\",\n                                  \"10\" = \"FCGR3A+ monocytes\",\n                                  \"11\" = \"B cells\",\n                                  \"12\" = \"NK cells\",\n                                  \"13\" = \"B cells\",\n                                  \"14\" = \"Conventional dendritic cells\",\n                                  \"15\" = \"Megakaryocytes\",\n                                  \"16\" = \"Activated T cells\", \n                                  \"17\" = \"Plasmacytoid dendritic cells\",\n                                  \"18\" = \"Unknown\")\n\n\n# Plot the UMAP\nDimPlot(object = seurat_clustered, \n        reduction = \"umap\", \n        label = TRUE,\n        label.size = 3,\n        repel = TRUE)\n\n\n\n\nAfter we have finished identifying cell types, often additional work is needed for validation or addressing additional questions. Some additional downstream work could include:\n\nExperimentally validate intriguing markers for our identified cell types.\nExplore a subset of the cell types to discover subclusters of cells as described here\nDifferential expression analysis within a particular cell type or subcluster.\nTrajectory analysis, or lineage tracing, could be performed if trying to determine the progression between cell types or cell states. For example, we could explore any of the following using this type of analysis:\n\nDifferentiation processes\nExpression changes over time\nCell state changes in expression"
  }
]